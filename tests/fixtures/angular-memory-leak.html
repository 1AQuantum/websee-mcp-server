<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Angular-style App with Memory Leaks - Test Fixture</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      padding: 20px;
      background: #f5f5f5;
    }
    .app {
      max-width: 1000px;
      margin: 0 auto;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .memory-monitor {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
    }
    .memory-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 15px;
    }
    .stat {
      background: rgba(255,255,255,0.2);
      padding: 15px;
      border-radius: 4px;
      backdrop-filter: blur(10px);
    }
    .stat-label {
      font-size: 12px;
      text-transform: uppercase;
      opacity: 0.9;
    }
    .stat-value {
      font-size: 28px;
      font-weight: bold;
      margin-top: 5px;
    }
    .leak-control {
      background: #fff3cd;
      border: 2px solid #ffc107;
      padding: 15px;
      border-radius: 4px;
      margin: 15px 0;
    }
    .leak-active {
      background: #f8d7da;
      border-color: #dc3545;
    }
    button {
      background: #667eea;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 4px;
      cursor: pointer;
      margin: 5px;
      font-size: 14px;
      transition: all 0.3s;
    }
    button:hover {
      background: #5568d3;
      transform: translateY(-2px);
    }
    button.danger {
      background: #dc3545;
    }
    button.danger:hover {
      background: #c82333;
    }
    button.success {
      background: #28a745;
    }
    button.success:hover {
      background: #218838;
    }
    .event-log {
      max-height: 300px;
      overflow-y: auto;
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      padding: 10px;
      font-family: monospace;
      font-size: 12px;
    }
    .event-entry {
      padding: 4px;
      border-bottom: 1px solid #e9ecef;
    }
    .event-entry:last-child {
      border-bottom: none;
    }
    .leak-source {
      background: #e7f3ff;
      border-left: 4px solid #007bff;
      padding: 15px;
      margin: 10px 0;
    }
    .leak-source code {
      background: #f1f3f5;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <div class="app" id="app">
    <h1>Angular-style App with Memory Leaks</h1>
    <p>This simulates common Angular memory leak patterns using vanilla JavaScript.</p>

    <div class="memory-monitor" id="memoryMonitor">
      <h2>Memory Monitor</h2>
      <div class="memory-stats">
        <div class="stat">
          <div class="stat-label">Heap Used</div>
          <div class="stat-value" id="heapUsed">0 MB</div>
        </div>
        <div class="stat">
          <div class="stat-label">Heap Total</div>
          <div class="stat-value" id="heapTotal">0 MB</div>
        </div>
        <div class="stat">
          <div class="stat-label">Active Timers</div>
          <div class="stat-value" id="activeTimers">0</div>
        </div>
        <div class="stat">
          <div class="stat-label">Active Listeners</div>
          <div class="stat-value" id="activeListeners">0</div>
        </div>
        <div class="stat">
          <div class="stat-label">DOM Nodes</div>
          <div class="stat-value" id="domNodes">0</div>
        </div>
        <div class="stat">
          <div class="stat-label">Memory Growth</div>
          <div class="stat-value" id="memoryGrowth">0%</div>
        </div>
      </div>
    </div>

    <div class="leak-control" id="leakControl">
      <h3>Memory Leak Controls</h3>

      <div class="leak-source">
        <strong>Leak #1: Unsubscribed Event Listeners</strong>
        <p>Creates event listeners that are never removed.</p>
        <code>document.addEventListener('click', handler)</code>
        <div style="margin-top: 10px;">
          <button onclick="startEventListenerLeak()" class="danger">Start Leak</button>
          <button onclick="stopEventListenerLeak()" class="success">Stop Leak</button>
        </div>
      </div>

      <div class="leak-source">
        <strong>Leak #2: Uncleaned Intervals/Timeouts</strong>
        <p>Creates intervals that are never cleared (common in ngOnDestroy omission).</p>
        <code>setInterval(() => { ... }, 100)</code>
        <div style="margin-top: 10px;">
          <button onclick="startIntervalLeak()" class="danger">Start Leak</button>
          <button onclick="stopIntervalLeak()" class="success">Stop Leak</button>
        </div>
      </div>

      <div class="leak-source">
        <strong>Leak #3: Detached DOM Elements</strong>
        <p>Creates DOM elements that are removed but still referenced.</p>
        <code>const el = document.createElement('div'); cache.push(el);</code>
        <div style="margin-top: 10px;">
          <button onclick="createDetachedElements()" class="danger">Create Detached Elements</button>
          <button onclick="clearDetachedElements()" class="success">Clear Cache</button>
        </div>
      </div>

      <div class="leak-source">
        <strong>Leak #4: Observable/RxJS Subscriptions</strong>
        <p>Simulates unsubscribed observables (common Angular pattern).</p>
        <code>observable.subscribe()</code>
        <div style="margin-top: 10px;">
          <button onclick="startObservableLeak()" class="danger">Start Subscriptions</button>
          <button onclick="stopObservableLeak()" class="success">Unsubscribe All</button>
        </div>
      </div>

      <div class="leak-source">
        <strong>Leak #5: Global References</strong>
        <p>Creates global variables that prevent garbage collection.</p>
        <code>window.globalData = new Array(10000)</code>
        <div style="margin-top: 10px;">
          <button onclick="createGlobalReferences()" class="danger">Create Globals</button>
          <button onclick="clearGlobalReferences()" class="success">Clear Globals</button>
        </div>
      </div>

      <div class="leak-source">
        <strong>Leak #6: Closure Memory Leak</strong>
        <p>Creates closures that capture large amounts of data.</p>
        <code>function outer() { const large = new Array(10000); return () => large; }</code>
        <div style="margin-top: 10px;">
          <button onclick="createClosureLeaks()" class="danger">Create Closures</button>
          <button onclick="clearClosureLeaks()" class="success">Clear Closures</button>
        </div>
      </div>
    </div>

    <div>
      <h3>Event Log</h3>
      <div class="event-log" id="eventLog"></div>
    </div>
  </div>

  <script>
    // Memory Leak Trackers
    const state = {
      eventListeners: [],
      intervals: [],
      timeouts: [],
      detachedElements: [],
      subscriptions: [],
      globalRefs: [],
      closures: [],
      listenerCount: 0,
      baselineMemory: 0,
    };

    // Logging
    function log(message) {
      const eventLog = document.getElementById('eventLog');
      const entry = document.createElement('div');
      entry.className = 'event-entry';
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      eventLog.insertBefore(entry, eventLog.firstChild);

      // Keep only last 50 entries
      while (eventLog.children.length > 50) {
        eventLog.removeChild(eventLog.lastChild);
      }
    }

    // Leak #1: Event Listeners
    function startEventListenerLeak() {
      const handler = () => {
        const data = new Array(1000).fill(Math.random());
        console.log('Event listener with large data', data.length);
      };

      // Add multiple listeners
      for (let i = 0; i < 10; i++) {
        document.addEventListener('click', handler);
        document.addEventListener('mousemove', handler);
        state.eventListeners.push({ type: 'click', handler });
        state.eventListeners.push({ type: 'mousemove', handler });
      }

      state.listenerCount += 20;
      log(`Started event listener leak. Added ${state.eventListeners.length} listeners.`);
      updateLeakStatus(true);
    }

    function stopEventListenerLeak() {
      state.eventListeners.forEach(({ type, handler }) => {
        document.removeEventListener(type, handler);
      });
      state.listenerCount -= state.eventListeners.length;
      state.eventListeners = [];
      log('Stopped event listener leak. Removed all listeners.');
      updateLeakStatus(false);
    }

    // Leak #2: Intervals
    function startIntervalLeak() {
      for (let i = 0; i < 10; i++) {
        const interval = setInterval(() => {
          const data = new Array(5000).fill(Math.random());
          console.log('Interval with large data', data.length);
        }, 100);
        state.intervals.push(interval);
      }
      log(`Started interval leak. ${state.intervals.length} active intervals.`);
      updateLeakStatus(true);
    }

    function stopIntervalLeak() {
      state.intervals.forEach(clearInterval);
      log(`Stopped interval leak. Cleared ${state.intervals.length} intervals.`);
      state.intervals = [];
      updateLeakStatus(false);
    }

    // Leak #3: Detached DOM Elements
    function createDetachedElements() {
      for (let i = 0; i < 100; i++) {
        const div = document.createElement('div');
        div.innerHTML = `<p>${'x'.repeat(1000)}</p>`.repeat(10);
        div.className = 'detached-element';

        // Add to DOM
        document.body.appendChild(div);

        // Remove from DOM but keep reference
        document.body.removeChild(div);

        // Store reference (prevents GC)
        state.detachedElements.push(div);
      }
      log(`Created ${state.detachedElements.length} detached DOM elements.`);
      updateLeakStatus(true);
    }

    function clearDetachedElements() {
      const count = state.detachedElements.length;
      state.detachedElements = [];
      log(`Cleared ${count} detached elements.`);
      updateLeakStatus(false);
    }

    // Leak #4: Observable/Subscription Pattern
    function createObservable(interval) {
      const subscribers = [];
      const id = setInterval(() => {
        const data = new Array(1000).fill(Math.random());
        subscribers.forEach(callback => callback(data));
      }, interval);

      return {
        subscribe: (callback) => {
          subscribers.push(callback);
          return {
            unsubscribe: () => {
              const index = subscribers.indexOf(callback);
              if (index > -1) subscribers.splice(index, 1);
              if (subscribers.length === 0) clearInterval(id);
            }
          };
        },
        _intervalId: id,
      };
    }

    function startObservableLeak() {
      for (let i = 0; i < 20; i++) {
        const observable = createObservable(100);
        const subscription = observable.subscribe((data) => {
          console.log('Observable data received', data.length);
        });
        // Never call unsubscribe - this is the leak!
        state.subscriptions.push(subscription);
      }
      log(`Started ${state.subscriptions.length} observable subscriptions without cleanup.`);
      updateLeakStatus(true);
    }

    function stopObservableLeak() {
      state.subscriptions.forEach(sub => sub.unsubscribe());
      const count = state.subscriptions.length;
      state.subscriptions = [];
      log(`Unsubscribed from ${count} observables.`);
      updateLeakStatus(false);
    }

    // Leak #5: Global References
    function createGlobalReferences() {
      for (let i = 0; i < 10; i++) {
        const key = `globalData${i}`;
        window[key] = {
          largeArray: new Array(10000).fill(Math.random()),
          timestamp: Date.now(),
          description: 'x'.repeat(1000),
        };
        state.globalRefs.push(key);
      }
      log(`Created ${state.globalRefs.length} global references.`);
      updateLeakStatus(true);
    }

    function clearGlobalReferences() {
      state.globalRefs.forEach(key => {
        delete window[key];
      });
      const count = state.globalRefs.length;
      state.globalRefs = [];
      log(`Cleared ${count} global references.`);
      updateLeakStatus(false);
    }

    // Leak #6: Closures
    function createClosureLeaks() {
      for (let i = 0; i < 50; i++) {
        const largeData = new Array(5000).fill(Math.random());
        const closure = () => {
          return largeData.length; // Captures largeData
        };
        state.closures.push(closure);
      }
      log(`Created ${state.closures.length} closures with large captured data.`);
      updateLeakStatus(true);
    }

    function clearClosureLeaks() {
      const count = state.closures.length;
      state.closures = [];
      log(`Cleared ${count} closures.`);
      updateLeakStatus(false);
    }

    // Update Memory Stats
    function updateMemoryStats() {
      if (performance.memory) {
        const used = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
        const total = Math.round(performance.memory.totalJSHeapSize / 1024 / 1024);

        if (!state.baselineMemory) {
          state.baselineMemory = used;
        }

        const growth = Math.round(((used - state.baselineMemory) / state.baselineMemory) * 100);

        document.getElementById('heapUsed').textContent = `${used} MB`;
        document.getElementById('heapTotal').textContent = `${total} MB`;
        document.getElementById('memoryGrowth').textContent = `${growth}%`;
      }

      document.getElementById('activeTimers').textContent = state.intervals.length;
      document.getElementById('activeListeners').textContent = state.listenerCount;
      document.getElementById('domNodes').textContent = document.getElementsByTagName('*').length;
    }

    function updateLeakStatus(active) {
      const leakControl = document.getElementById('leakControl');
      if (active) {
        leakControl.classList.add('leak-active');
      } else {
        leakControl.classList.remove('leak-active');
      }
    }

    // Start monitoring
    setInterval(updateMemoryStats, 1000);
    updateMemoryStats();

    log('Memory leak test app initialized.');
  </script>
</body>
</html>
