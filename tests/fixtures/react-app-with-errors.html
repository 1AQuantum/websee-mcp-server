<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>React App with Errors - Test Fixture</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      padding: 20px;
      background: #f5f5f5;
    }
    .app {
      max-width: 800px;
      margin: 0 auto;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .error-boundary {
      background: #fee;
      border: 2px solid #c00;
      padding: 20px;
      border-radius: 4px;
      margin: 10px 0;
    }
    button {
      background: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      margin: 5px;
    }
    button:hover {
      background: #0056b3;
    }
    .counter {
      font-size: 24px;
      margin: 20px 0;
    }
    .user-list {
      list-style: none;
      padding: 0;
    }
    .user-item {
      padding: 10px;
      margin: 5px 0;
      background: #f0f0f0;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useCallback, useMemo } = React;

    // Error Boundary Component
    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { hasError: false, error: null };
      }

      static getDerivedStateFromError(error) {
        return { hasError: true, error };
      }

      componentDidCatch(error, errorInfo) {
        console.error('Error caught by boundary:', error, errorInfo);
      }

      render() {
        if (this.state.hasError) {
          return (
            <div className="error-boundary">
              <h2>Something went wrong!</h2>
              <p>{this.state.error?.message}</p>
              <button onClick={() => this.setState({ hasError: false, error: null })}>
                Reset
              </button>
            </div>
          );
        }

        return this.props.children;
      }
    }

    // Component with undefined property access error
    function BuggyCounter() {
      const [count, setCount] = useState(0);
      const [data, setData] = useState(null);

      const handleClick = () => {
        // This will cause an error when data is null
        console.log(data.value.toString());
        setCount(count + 1);
      };

      return (
        <div className="buggy-component">
          <h2>Buggy Counter Component</h2>
          <div className="counter">Count: {count}</div>
          <button onClick={handleClick}>
            Trigger Undefined Error
          </button>
          <button onClick={() => setCount(count + 1)}>
            Safe Increment
          </button>
        </div>
      );
    }

    // Component with async error
    function AsyncBuggyComponent() {
      const [users, setUsers] = useState([]);
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState(null);

      const fetchUsers = useCallback(async () => {
        setLoading(true);
        setError(null);
        try {
          // Intentional error: accessing non-existent API
          const response = await fetch('https://api.example.com/users/invalid-endpoint-12345');
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const data = await response.json();
          // This will fail: trying to access property on undefined
          setUsers(data.users.list);
        } catch (err) {
          setError(err.message);
          console.error('Fetch error:', err);
        } finally {
          setLoading(false);
        }
      }, []);

      return (
        <div className="async-buggy">
          <h2>Async Buggy Component</h2>
          <button onClick={fetchUsers} disabled={loading}>
            {loading ? 'Loading...' : 'Fetch Users (Will Fail)'}
          </button>
          {error && <div className="error-boundary"><p>Error: {error}</p></div>}
          {users.length > 0 && (
            <ul className="user-list">
              {users.map(user => (
                <li key={user.id} className="user-item">{user.name}</li>
              ))}
            </ul>
          )}
        </div>
      );
    }

    // Component with state update error
    function StateUpdateBug() {
      const [items, setItems] = useState([]);

      const addItem = () => {
        // Intentional bug: trying to modify state directly
        const newItems = items;
        newItems.push({ id: Date.now(), text: 'New item' });
        setItems(newItems); // This won't trigger re-render properly

        // Correct way would be:
        // setItems([...items, { id: Date.now(), text: 'New item' }]);
      };

      const causeTypeError = () => {
        // Intentional: accessing undefined
        const obj = undefined;
        return obj.property.nested.value;
      };

      return (
        <div className="state-bug">
          <h2>State Update Bug</h2>
          <button onClick={addItem}>Add Item (Buggy)</button>
          <button onClick={causeTypeError}>Cause TypeError</button>
          <div>Items: {items.length}</div>
        </div>
      );
    }

    // Component with infinite loop potential
    function InfiniteLoopRisk() {
      const [count, setCount] = useState(0);

      // This effect will cause infinite re-renders if uncommented
      // useEffect(() => {
      //   setCount(count + 1);
      // }, [count]);

      const triggerInfiniteLoop = () => {
        // Simulated infinite loop
        let i = 0;
        const interval = setInterval(() => {
          i++;
          setCount(c => c + 1);
          if (i > 1000) {
            clearInterval(interval);
          }
        }, 1);
      };

      return (
        <div className="infinite-loop-component">
          <h2>Infinite Loop Risk</h2>
          <div>Count: {count}</div>
          <button onClick={triggerInfiniteLoop}>
            Trigger Rapid Updates
          </button>
        </div>
      );
    }

    // Component with memory leak
    function MemoryLeakComponent() {
      const [active, setActive] = useState(false);

      useEffect(() => {
        if (active) {
          // Memory leak: interval not cleared when component unmounts
          const interval = setInterval(() => {
            console.log('Interval running...', Date.now());
          }, 100);

          // Missing cleanup:
          // return () => clearInterval(interval);
        }
      }, [active]);

      return (
        <div className="memory-leak">
          <h2>Memory Leak Component</h2>
          <button onClick={() => setActive(!active)}>
            {active ? 'Stop' : 'Start'} Interval (Memory Leak)
          </button>
        </div>
      );
    }

    // Main App Component
    function App() {
      const [showBuggyCounter, setShowBuggyCounter] = useState(false);
      const [showAsyncBuggy, setShowAsyncBuggy] = useState(false);
      const [showStateBug, setShowStateBug] = useState(false);
      const [showInfiniteLoop, setShowInfiniteLoop] = useState(false);
      const [showMemoryLeak, setShowMemoryLeak] = useState(false);

      return (
        <div className="app">
          <h1>React App with Errors - Test Fixture</h1>
          <p>This app contains various bugs for testing error detection and debugging tools.</p>

          <div>
            <h3>Toggle Components:</h3>
            <button onClick={() => setShowBuggyCounter(!showBuggyCounter)}>
              {showBuggyCounter ? 'Hide' : 'Show'} Buggy Counter
            </button>
            <button onClick={() => setShowAsyncBuggy(!showAsyncBuggy)}>
              {showAsyncBuggy ? 'Hide' : 'Show'} Async Buggy
            </button>
            <button onClick={() => setShowStateBug(!showStateBug)}>
              {showStateBug ? 'Hide' : 'Show'} State Bug
            </button>
            <button onClick={() => setShowInfiniteLoop(!showInfiniteLoop)}>
              {showInfiniteLoop ? 'Hide' : 'Show'} Infinite Loop Risk
            </button>
            <button onClick={() => setShowMemoryLeak(!showMemoryLeak)}>
              {showMemoryLeak ? 'Hide' : 'Show'} Memory Leak
            </button>
          </div>

          <hr />

          {showBuggyCounter && (
            <ErrorBoundary key="buggy-counter">
              <BuggyCounter />
            </ErrorBoundary>
          )}

          {showAsyncBuggy && (
            <ErrorBoundary key="async-buggy">
              <AsyncBuggyComponent />
            </ErrorBoundary>
          )}

          {showStateBug && (
            <ErrorBoundary key="state-bug">
              <StateUpdateBug />
            </ErrorBoundary>
          )}

          {showInfiniteLoop && (
            <ErrorBoundary key="infinite-loop">
              <InfiniteLoopRisk />
            </ErrorBoundary>
          )}

          {showMemoryLeak && (
            <ErrorBoundary key="memory-leak">
              <MemoryLeakComponent />
            </ErrorBoundary>
          )}
        </div>
      );
    }

    // Render app
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);

    // Global error handler for uncaught errors
    window.addEventListener('error', (event) => {
      console.error('Uncaught error:', event.error);
    });

    window.addEventListener('unhandledrejection', (event) => {
      console.error('Unhandled promise rejection:', event.reason);
    });
  </script>
</body>
</html>
